<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Smoldot WebRTC WASM Demo</title>
    <style>
        /* body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #0056b3;
        } */
        #output {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            min-height: 100px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<h1>Smoldot WebRTC WASM</h1>

<input
        id="peerAddress"
        type="text"
        placeholder="Enter peer multiaddress"
>
<button id="runDemo" onclick="runDemo()">Run WebRTC Demo</button>

<div id="output"></div>


<script type="module">
  import {multiaddr, CODE_IP4, CODE_UDP, CODE_CERTHASH} from 'https://esm.sh/@multiformats/multiaddr@12.5.1';
  import {base64url} from 'https://esm.sh/multiformats@13.4.0/bases/base64';
  import init, {run_client} from './pkg/smoldot_webrtc_wasm.js';

  const maxMessageSize = 16384;

  window.runDemo = async function () {
    const output = document.getElementById('output');
    output.textContent = 'Loading WASM module...\n';

    try {
      await init();
      output.textContent += 'WASM module loaded successfully!\n';
    } catch (error) {
      output.textContent += `Error: ${error}\n`;
    }

    output.textContent += 'Running WebRTC demo...\n';
    const peer = document.getElementById('peerAddress').value;

    await run_client(peer).catch(error => {
      output.textContent += `\n\n${error}\n`;
    });
  };

  const channels = {}; // channelId -> DataChannel

  export function sendTo(channelId, data) {
    // console.log(`JS: sending ${data.length} byte(s) to channel ${channelId}: ${String(data)}`);

    const channel = channels[channelId];

    if (!channel) {
      throw new Error(`JS: channel ${channelId} not found`);
    }

    if (channel.readyState !== 'open') {
      throw new Error(`JS: channel ${channelId} is not in ready state`);
    }

    channel.send(data);
  }

  globalThis.sendTo = sendTo;

  export async function generateCertificate() {
    return await RTCPeerConnection.generateCertificate({
      name: 'ECDSA',
      hash: 'SHA-256',
      namedCurve: 'P-256',
    });
  }

  globalThis.generateCertificate = generateCertificate;

  export function getCertificateMultihash(certificate) {
    const fp = certificate.getFingerprints().find(f => f.algorithm.toUpperCase() === 'SHA-256');
    if (!fp) throw new Error('No SHA-256 fingerprint on certificate');

    const clean = fp.value.replace(/:/g, '');
    const out = new Uint8Array(clean.length / 2);

    for (let i = 0; i < out.length; i++) {
      out[i] = Number.parseInt(clean.slice(i * 2, i * 2 + 2), 16);
    }

    const mh = new Uint8Array(2 + 32);
    mh[0] = 0x12;
    mh[1] = 0x20;
    mh.set(out, 2);
    return mh;
  }

  globalThis.getCertificateMultihash = getCertificateMultihash;

  export function now() {
    return performance.now();
  }

  globalThis.now = now;

  globalThis.smoldotGlue = {
    // datachannel has been opened by the remote
    onDatachannelOpen: (channelId) => {
      console.log(`JS: glue stub onDatachannelOpen() channelId: ${channelId}`);
    },
    // locally opened datachannel is ready for bizniz
    onDatachannelReady: (channelId) => {
      console.log(`JS: glue stub onDatachannelReady() channelId: ${channelId}`);
    },
    onDatachannelClose: (channelId) => {
      console.log(`JS: glue stub onDatachannelClose(): channelId: ${channelId}`);
      delete channels[channelId];
    },
    onDatachannelError: (channelId, msg) => {
      console.log(`JS: glue stub onDatachannelError(): channelId: ${channelId}, msg: ${msg}`);
      delete channels[channelId];
    },
    onMessage: (channelId, _data) => {
      console.log(`JS: glue stub onMessage(): channelId: ${channelId}`);
    },
    onTimeElapsed: () => {
      console.log(`JS: glue stub onTimeElapsed()`);
    }
  }

  export function setGlue(glue) {
    globalThis.smoldotGlue = glue;
  }

  globalThis.setGlue = setGlue;

  export function createDatachannel() {
    const dc = globalThis.rtcPeerConnection.createDataChannel('', {
      ordered: true,
    });

    dc.onopen = event => globalThis.smoldotGlue.onDatachannelReady(event.target.id);

    configureDatachannel(dc);

    return dc.id;
  }

  globalThis.createDatachannel = createDatachannel;

  export async function dialWebRtcDirect(address, certificate) {
    const pc = new RTCPeerConnection({certificates: [certificate], iceServers: []});
    globalThis.rtcPeerConnection = pc;

    pc.ondatachannel = event => {
      channels[event.channel.id] = event.channel;

      event.channel.onmessage = dataEvent => {
        const data = new Uint8Array(dataEvent.data);
        // console.log(`JS: ${data.length} bytes received on channel ${event.channel.id}: ${String(data)}`);
        globalThis.smoldotGlue.onMessage(event.channel.id, data);
      };

      event.channel.onclose = () => {
        globalThis.smoldotGlue.onDatachannelClose(event.channel.id);
      }

      event.channel.onerror = err => {
        const msg = `${err}`;
        globalThis.smoldotGlue.onDatachannelError(event.channel.id, msg);
      }

      globalThis.smoldotGlue.onDatachannelOpen(event.channel.id);
    };

    const dc = pc.createDataChannel('', {
      negotiated: true,
      id: 0,
      ordered: true,
    });

    configureDatachannel(dc);

    // Build answer and offer with patched ICE ufrag/pwd with libp2p tag
    const ufrag = `libp2p+webrtc+v1/${randomString()}`;

    const offer = await pc.createOffer({offerToReceiveAudio: false, offerToReceiveVideo: false});
    offer.sdp = mungeOffer(offer.sdp, ufrag);

    await pc.setLocalDescription(offer);

    const ma = multiaddr(address);
    const componentsByCode = {};
    ma.getComponents().forEach(c => componentsByCode[c.code] = c.value);

    const {[CODE_IP4]: ip, [CODE_UDP]: port, [CODE_CERTHASH]: certhash} = componentsByCode;
    const answer = buildAnswer(ip, port, certhash, ufrag);

    setInterval(() => {
      globalThis.smoldotGlue.onTimeElapsed();
    }, 100);

    await pc.setRemoteDescription(answer);
  }

  globalThis.dialWebRtcDirect = dialWebRtcDirect;

  function configureDatachannel(dc) {
    channels[dc.id] = dc;
    dc.binaryType = 'arraybuffer';

    dc.onmessage = event => {
      const data = new Uint8Array(event.data);
      // console.log(`JS: ${data.length} bytes received on channel ${dc.id}`); //: ${data}`);
      globalThis.smoldotGlue.onMessage(dc.id, data);
    };

    dc.onclose = () => {
      globalThis.smoldotGlue.onDatachannelClose(dc.id);
      delete channels[channelId];
    }

    dc.onerror = err => {
      const msg = `${err}`;
      globalThis.smoldotGlue.onDatachannelError(dc.id, msg);
      delete channels[channelId];
    }
  }

  function buildAnswer(ip, port, certhash, ufrag) {
    // Single host candidate, ICE-lite, DTLS passive, SCTP port 5000, max message size 16KiB.
    const sdp = [
      'v=0',
      'o=- 0 0 IN IP4 127.0.0.1',
      's=-',
      't=0 0',
      'a=ice-lite',
      `a=fingerprint:sha-256 ${certhashToSdpFingerprint(certhash)}`,
      `a=ice-ufrag:${ufrag}`,
      `a=ice-pwd:${ufrag}`,
      'a=setup:passive',
      'm=application 9 UDP/DTLS/SCTP webrtc-datachannel',
      `c=IN IP4 ${ip}`,
      'a=mid:0',
      `a=candidate:1 1 UDP 2130706431 ${ip} ${port} typ host`,
      'a=end-of-candidates',
      'a=sctp-port:5000',
      `a=max-message-size:${maxMessageSize}`,
    ].join('\r\n') + '\r\n';

    return {
      type: 'answer',
      sdp: sdp,
    }
  }

  function mungeOffer(sdp, ufrag) {
    return sdp
      .replace(/a=ice-ufrag:.+\r\n/, `a=ice-ufrag:${ufrag}\r\n`)
      .replace(/a=ice-pwd:.+\r\n/, `a=ice-pwd:${ufrag}\r\n`)
      .replace(/a=max-message-size:.+\r\n/, `a=max-message-size:${maxMessageSize}\r\n`);
  }

  function certhashToSdpFingerprint(certhash) {
    // certhash is multibase; 'u' means base64url (no padding)
    if (!certhash || certhash[0] !== 'u') {
      throw new Error('Expected base64url multibase certhash starting with "u"');
    }

    const mh = base64url.decode(certhash);
    // Multihash: 0x12 = sha2-256, 0x20 = 32 bytes
    if (mh.length !== 34 || mh[0] !== 0x12 || mh[1] !== 0x20) {
      throw new Error('Unsupported certhash multihash; expected sha2-256/32');
    }

    const digest = mh.slice(2); // 32-byte SHA-256
    return Array.from(digest)
      .map(b => b.toString(16).padStart(2, '0'))
      .join(':')
      .toUpperCase();
  }

  function randomString(len = 5) {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const arr = new Uint8Array(len);
    crypto.getRandomValues(arr);
    let s = '';
    for (let i = 0; i < len; i++) s += chars[arr[i] % chars.length];
    return s;
  }

</script>
</body>
</html>
