<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Smoldot WebRTC WASM Demo</title>
    <style>
        /* body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #0056b3;
        } */
        #output {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            min-height: 100px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<h1>Smoldot WebRTC WASM</h1>

<input
        id="peerAddress"
        type="text"
        placeholder="Enter peer multiaddress"
>
<button onclick="runDemo()">Run WebRTC Demo</button>

<div id="output"></div>

<script type="module">
  import {multiaddr, CODE_IP4, CODE_UDP, CODE_CERTHASH} from 'https://esm.sh/@multiformats/multiaddr@12.5.1';
  import {base64url} from 'https://esm.sh/multiformats@13.4.0/bases/base64';
  import init, {run_client} from './pkg/smoldot_webrtc_wasm.js';

  const maxMessageSize = 16384;

  window.runDemo = async function () {
    const output = document.getElementById('output');
    output.textContent = 'Loading WASM module...\n';

    try {
      await init();
      output.textContent += 'WASM module loaded successfully!\n';
    } catch (error) {
      output.textContent += `Error: ${error}\n`;
    }

    output.textContent += 'Running WebRTC demo...\n';
    const peer = document.getElementById('peerAddress').value;

    await run_client(peer, sendTo).catch(error => {
      output.textContent += `\n\n${error}\n`;
    });
  };

  const channels = {}; // channelId -> DataChannel

  export function sendTo(channelId, data) {
    const channel = channels[channelId];

    if (!channel) {
      console.error(`JS: channel ${channelId} not found`);
      return;
    }

    if (channel.readyState !== 'open') {
      console.error(`JS: channel ${channelId} is not in ready state`);
      return;
    }

    channel.send(data);
  }

  export async function generateCertificate() {
    return await RTCPeerConnection.generateCertificate({
      name: 'ECDSA',
      hash: 'SHA-256',
      namedCurve: 'P-256',
    });
  }

  globalThis.generateCertificate = generateCertificate;

  export function getCertificateFingerprint(certificate) {
    const fp = certificate.getFingerprints().find(f => f.algorithm.toUpperCase() === 'SHA-256');
    if (!fp) throw new Error('No SHA-256 fingerprint on certificate');

    const clean = fp.value.replace(/:/g, '');
    const out = new Uint8Array(clean.length / 2);

    for (let i = 0; i < out.length; i++) {
      out[i] = Number.parseInt(clean.slice(i * 2, i * 2 + 2), 16);
    }

    return out;
  }

  globalThis.getCertificateFingerprint = getCertificateFingerprint;

  // glue should have the following method(s):
  // onMessage(channelId: Number, data: Uint8Array): void;
  export async function dialWebRtcDirect(address, certificate, glue) {
    const pc = new RTCPeerConnection({certificates: [certificate], iceServers: []});

    pc.ondatachannel = event => {
      console.log(`JS: datachannel event. channel id: ${event.channel.id}`);
      channels[event.channel.id] = event.channel;

      event.channel.onmessage = dataEvent => {
        const data = new Uint8Array(dataEvent.data);
        console.log(`JS: ${data.length} bytes received on channel ${event.channel.id}`);
        glue.onMessage(event.channel.id, data);
      };
    };

    // Build answer and offer with patched ICE ufrag/pwd with libp2p tag
    const ufrag = `libp2p+webrtc+v1/${randomString()}`;

    const offer = await pc.createOffer({offerToReceiveAudio: false, offerToReceiveVideo: false});
    offer.sdp = mungeOffer(offer.sdp, ufrag);

    console.log('JS: offer');
    console.log(offer.sdp);

    await pc.setLocalDescription(offer);

    const ma = multiaddr(address);
    const componentsByCode = {};
    ma.getComponents().forEach(c => componentsByCode[c.code] = c.value);

    const {[CODE_IP4]: ip, [CODE_UDP]: port, [CODE_CERTHASH]: certhash} = componentsByCode;
    console.log(`JS: connecting to ${ip}:${port} with certhash ${certhash}`);
    const answer = buildAnswer(ip, port, certhash, ufrag);

    console.log('JS: answer');
    console.log(answer.sdp);

    await pc.setRemoteDescription(answer);

    console.log('JS: creating datachannel');

    const dc = pc.createDataChannel('', {
      negotiated: true,
      id: 0,
      ordered: true,
    });

    dc.binaryType = 'arraybuffer';
    dc.onmessage = event => {
      const data = new Uint8Array(event.data);
      glue.onMessage(event.channel.id, data);
    };

    dc.onclose = () => console.log('JS: channel 0 closed');
    dc.onerror = err => console.error(`JS: channel 0 error: ${err.message}`);
  }

  globalThis.dialWebRtcDirect = dialWebRtcDirect;

  function buildAnswer(ip, port, certhash, ufrag) {
    // Single host candidate, ICE-lite, DTLS passive, SCTP port 5000, max message size 16KiB.
    const sdp = [
      'v=0',
      'o=- 0 0 IN IP4 127.0.0.1',
      's=-',
      't=0 0',
      'a=ice-lite',
      `a=fingerprint:sha-256 ${certhashToSdpFingerprint(certhash)}`,
      `a=ice-ufrag:${ufrag}`,
      `a=ice-pwd:${ufrag}`,
      'a=setup:passive',
      'm=application 9 UDP/DTLS/SCTP webrtc-datachannel',
      `c=IN IP4 ${ip}`,
      'a=mid:0',
      `a=candidate:1 1 UDP 2130706431 ${ip} ${port} typ host`,
      'a=end-of-candidates',
      'a=sctp-port:5000',
      `a=max-message-size:${maxMessageSize}`,
    ].join('\r\n') + '\r\n';

    return {
      type: 'answer',
      sdp: sdp,
    }
  }

  function mungeOffer(sdp, ufrag) {
    let munged = sdp
      .replace(/a=ice-ufrag:.+\r\n/, `a=ice-ufrag:${ufrag}\r\n`)
      .replace(/a=ice-pwd:.+\r\n/, `a=ice-pwd:${ufrag}\r\n`)
      .replace(/a=max-message-size:.+\r\n/, `a=max-message-size:${maxMessageSize}\r\n`);

    return `${munged}m=application 9 UDP/DTLS/SCTP webrtc-datachannel\r\na=mid:0\r\n`;
  }

  function certhashToSdpFingerprint(certhash) {
    // certhash is multibase; 'u' means base64url (no padding)
    if (!certhash || certhash[0] !== 'u') {
      throw new Error('Expected base64url multibase certhash starting with "u"');
    }

    const mh = base64url.decode(certhash);
    // Multihash: 0x12 = sha2-256, 0x20 = 32 bytes
    if (mh.length !== 34 || mh[0] !== 0x12 || mh[1] !== 0x20) {
      throw new Error('Unsupported certhash multihash; expected sha2-256/32');
    }

    const digest = mh.slice(2); // 32-byte SHA-256
    return Array.from(digest)
      .map(b => b.toString(16).padStart(2, '0'))
      .join(':')
      .toUpperCase();
  }

  function randomString(len = 5) {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const arr = new Uint8Array(len);
    crypto.getRandomValues(arr);
    let s = '';
    for (let i = 0; i < len; i++) s += chars[arr[i] % chars.length];
    return s;
  }

</script>
</body>
</html>
